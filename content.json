[{"title":"android万能适配器","date":"2018-06-15T06:01:55.000Z","path":"2018/06/15/android万能适配器/","text":"转载请标明出处：(http://blog.csdn.net/lmj623565791/article/details/38902805) ，本文出自【张鸿洋的博客】 1、概述相信做Android开发的写得最多的就是ListView，GridView的适配器吧，记得以前开发一同事开发项目，一个项目下来基本就一直在写ListView的Adapter都快吐了 对于Adapter一般都继承BaseAdapter复写几个方法，getView里面使用ViewHolder模式，其实大部分的代码基本都是类似的。本篇博客为快速开发系列的第一篇，将一步一步带您封装出一个通用的Adapter。 2、常见的例子首先看一个最常见的案例，大家一目十行的扫一眼 1、布局文件主布局文件： 123456789101112[html] view plain copy&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;ListView android:id=&quot;@+id/id_lv_main&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; /&gt; &lt;/RelativeLayout&gt; Item的布局文件：123456789101112131415[html] view plain copy&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/id_tv_title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;#aa111111&quot; android:gravity=&quot;center_vertical&quot; android:paddingLeft=&quot;15dp&quot; android:textColor=&quot;#ffffff&quot; android:text=&quot;hello&quot; android:textSize=&quot;20sp&quot; android:textStyle=&quot;bold&quot; &gt; &lt;/TextView&gt; 2、Adapter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869[java] view plain copypackage com.example.zhy_baseadapterhelper; import java.util.List; import android.content.Context; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.BaseAdapter; import android.widget.TextView; public class MyAdapter extends BaseAdapter &#123; private LayoutInflater mInflater; private Context mContext; private List&lt;String&gt; mDatas; public MyAdapter(Context context, List&lt;String&gt; mDatas) &#123; mInflater = LayoutInflater.from(context); this.mContext = context; this.mDatas = mDatas; &#125; @Override public int getCount() &#123; return mDatas.size(); &#125; @Override public Object getItem(int position) &#123; return mDatas.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder viewHolder = null; if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.item_single_str, parent, false); viewHolder = new ViewHolder(); viewHolder.mTextView = (TextView) convertView .findViewById(R.id.id_tv_title); convertView.setTag(viewHolder); &#125; else &#123; viewHolder = (ViewHolder) convertView.getTag(); &#125; viewHolder.mTextView.setText(mDatas.get(position)); return convertView; &#125; private final class ViewHolder &#123; TextView mTextView; &#125; &#125; 3、Activity123456789101112131415161718192021222324252627282930[java] view plain copypackage com.example.zhy_baseadapterhelper; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import android.app.Activity; import android.os.Bundle; import android.widget.ListView; public class MainActivity extends Activity &#123; private ListView mListView; private List&lt;String&gt; mDatas = new ArrayList&lt;String&gt;(Arrays.asList(&quot;Hello&quot;, &quot;World&quot;, &quot;Welcome&quot;)); private MyAdapter mAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mListView = (ListView) findViewById(R.id.id_lv_main); mListView.setAdapter(mAdapter = new MyAdapter(this, mDatas)); &#125; &#125; 上面这个例子大家应该都写了无数遍了，MyAdapter集成BaseAdapter，然后getView里面使用ViewHolder模式；一般情况下，我们的写法是这样的：对于不同布局的ListView，我们会有一个对应的Adapter，在Adapter中又会有一个ViewHolder类来提高效率。这样出现ListView就会出现与之对于的Adapter类、ViewHolder类；那么有没有办法减少我们的编码呢？ 下面首先拿ViewHolder开刀~ 3、通用的ViewHolder首先分析下ViewHolder的作用，通过convertView.setTag与convertView进行绑定，然后当convertView复用时，直接从与之对于的ViewHolder(getTag)中拿到convertView布局中的控件，省去了findViewById的时间~ 也就是说，实际上们每个convertView会绑定一个ViewHolder对象，这个viewHolder主要用于帮convertView存储布局中的控件。 那么我们只要写出一个通用的ViewHolder，然后对于任意的convertView，提供一个对象让其setTag即可； 既然是通用，那么我们这个ViewHolder就不可能含有各种控件的成员变量了，因为每个Item的布局是不同的，最好的方式是什么呢？ 提供一个容器，专门存每个Item布局中的所有控件，而且还要能够查找出来；既然需要查找，那么ListView肯定是不行了，需要一个键值对进行保存，键为控件的Id，值为控件的引用，相信大家立刻就能想到Map；但是我们不用Map，因为有更好的替代类，就是我们android提供的SparseArray这个类，和Map类似，但是比Map效率，不过键只能为Integer. 下面看我们的ViewHolder类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273[java] view plain copypackage com.example.zhy_baseadapterhelper; import android.content.Context; import android.util.Log; import android.util.SparseArray; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; public class ViewHolder &#123; private final SparseArray&lt;View&gt; mViews; private View mConvertView; private ViewHolder(Context context, ViewGroup parent, int layoutId, int position) &#123; this.mViews = new SparseArray&lt;View&gt;(); mConvertView = LayoutInflater.from(context).inflate(layoutId, parent, false); //setTag mConvertView.setTag(this); &#125; /** * 拿到一个ViewHolder对象 * @param context * @param convertView * @param parent * @param layoutId * @param position * @return */ public static ViewHolder get(Context context, View convertView, ViewGroup parent, int layoutId, int position) &#123; if (convertView == null) &#123; return new ViewHolder(context, parent, layoutId, position); &#125; return (ViewHolder) convertView.getTag(); &#125; /** * 通过控件的Id获取对于的控件，如果没有则加入views * @param viewId * @return */ public &lt;T extends View&gt; T getView(int viewId) &#123; View view = mViews.get(viewId); if (view == null) &#123; view = mConvertView.findViewById(viewId); mViews.put(viewId, view); &#125; return (T) view; &#125; public View getConvertView() &#123; return mConvertView; &#125; &#125; 与传统的ViewHolder不同，我们使用了一个SparseArray用于存储与之对于的convertView的所有的控件，当需要拿这些控件时，通过getView(id)进行获取； 下面看使用该ViewHolder的MyAdapter；12345678910111213[java] view plain copy@Override public View getView(int position, View convertView, ViewGroup parent) &#123; //实例化一个viewHolder ViewHolder viewHolder = ViewHolder.get(mContext, convertView, parent, R.layout.item_single_str, position); //通过getView获取控件 TextView tv = viewHolder.getView(R.id.id_tv_title); //使用 tv.setText(mDatas.get(position)); return viewHolder.getConvertView(); &#125; 只看getView，其他方法都一样；首先调用ViewHolder的get方法，如果convertView为null，new一个ViewHolder实例，通过使用mInflater.inflate加载布局，然后new一个SparseArray用于存储View，最后setTag(this)；如果存在那么直接getTag 最后通过getView(id)获取控件，如果存在则直接返回，否则调用findViewById，返回存储，返回。 好了，一个通用的ViewHolder写好了，以后一个项目几十个Adapter一个ViewHolder直接hold住全场 大家可以省点时间斗个小地主了 4、打造通用的Adapter有了通用的ViewHolder大家肯定不能满足，怎么也得省出dota的时间，人在塔在~~ 下面看如何打造一个通过的Adapter，我们叫做CommonAdapter 继续分析，Adapter一般需要保持一个List对象，存储一个Bean的集合，不同的ListView，Bean肯定是不同的，这个CommonAdapter肯定需要支持泛型，内部维持一个List，就解决我们的问题了； 于是我们初步打造我们的CommonAdapter 1234567891011121314151617181920212223242526272829303132333435363738394041424344[java] view plain copypackage com.example.zhy_baseadapterhelper; import java.util.List; import android.content.Context; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.BaseAdapter; import android.widget.TextView; public abstract class CommonAdapter&lt;T&gt; extends BaseAdapter &#123; protected LayoutInflater mInflater; protected Context mContext; protected List&lt;T&gt; mDatas; public CommonAdapter(Context context, List&lt;T&gt; mDatas) &#123; mInflater = LayoutInflater.from(context); this.mContext = context; this.mDatas = mDatas; &#125; @Override public int getCount() &#123; return mDatas.size(); &#125; @Override public Object getItem(int position) &#123; return mDatas.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; &#125; 我们的CommonAdapter依然是一个抽象类，除了getView以外我们把其他的代码都实现了，这样的话，在使用我们的Adapter只要实现一个getView，然后getView里面再使用我们打造的通过的ViewHolder是不是感觉还不错~现在我们的MyAdapter是这样的：12345678910111213141516171819202122232425262728[java] view plain copypackage com.example.zhy_baseadapterhelper; import java.util.List; import android.content.Context; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; public class MyAdapter&lt;T&gt; extends CommonAdapter&lt;T&gt; &#123; public MyAdapter(Context context, List&lt;T&gt; mDatas) &#123; super(context, mDatas); &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder viewHolder = ViewHolder.get(mContext, convertView, parent, R.layout.item_single_str, position); TextView mTitle = viewHolder.getView(R.id.id_tv_title); mTitle.setText((String) mDatas.get(position)); return viewHolder.getConvertView(); &#125; &#125; 所有的代码加起来也就10行左右，是不是神清气爽~~稍等，我先去dota一把~但是我们是否就这样满足了呢？显然还可以简化。 5、进一步铸造注意我们的getView里面的代码，虽然只有4行，但是我觉得所有的Adapter的 第一行（ViewHolder viewHolder = getViewHolder(position, convertView,parent);）和 最后一行：return viewHolder.getConvertView();一定是一样的。 那么我们可以这样做：我们把第一行和最后一行写死，把中间变化的部分抽取出来，这不就是OO的设计原则嘛。现在CommonAdapter是这样的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[java] view plain copypackage com.example.zhy_baseadapterhelper; import java.util.List; import android.content.Context; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.BaseAdapter; public abstract class CommonAdapter&lt;T&gt; extends BaseAdapter &#123; protected LayoutInflater mInflater; protected Context mContext; protected List&lt;T&gt; mDatas; protected final int mItemLayoutId; public CommonAdapter(Context context, List&lt;T&gt; mDatas, int itemLayoutId) &#123; this.mContext = context; this.mInflater = LayoutInflater.from(mContext); this.mDatas = mDatas; this.mItemLayoutId = itemLayoutId; &#125; @Override public int getCount() &#123; return mDatas.size(); &#125; @Override public T getItem(int position) &#123; return mDatas.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; final ViewHolder viewHolder = getViewHolder(position, convertView, parent); convert(viewHolder, getItem(position)); return viewHolder.getConvertView(); &#125; public abstract void convert(ViewHolder helper, T item); private ViewHolder getViewHolder(int position, View convertView, ViewGroup parent) &#123; return ViewHolder.get(mContext, convertView, parent, mItemLayoutId, position); &#125; &#125; 对外公布了一个convert方法，并且还把viewHolder和本Item对于的Bean对象给传出去，现在convert方法里面需要干嘛呢？通过ViewHolder把View找到，通过Item设置值； 现在我觉得代码简化到这样，我已经不需要单独写一个Adapter了，直接MainActivity匿名内部类走起~12345678910111213141516171819202122[java] view plain copy@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mListView = (ListView) findViewById(R.id.id_lv_main); //设置适配器 mListView.setAdapter(mAdapter = new CommonAdapter&lt;String&gt;( getApplicationContext(), mDatas, R.layout.item_single_str) &#123; @Override public void convert(ViewHolder c, String item) &#123; TextView view = viewHolder.getView(R.id.id_tv_title); view.setText(item); &#125; &#125;); &#125; 可以看到效果咋样，不错吧。你觉得还能简化么？我觉得还能改善。6、Adapter最后的封魔我们现在在convertView里面需要这样:123456@Overridepublic void convert(ViewHolder viewHolder, String item)&#123; TextView view = viewHolder.getView(R.id.id_tv_title); view.setText(item);&#125; 我们细想一下，其实布局里面的View常用也就那么几种：ImageView,TextView,Button,CheckBox等等； 那么我觉得ViewHolder还可以封装一些常用的方法，比如setText(id,String)；setImageResource(viewId, resId)；setImageBitmap(viewId, bitmap)； 那么现在ViewHolder是：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136[java] view plain copypackage com.example.zhy_baseadapterhelper; import android.content.Context; import android.graphics.Bitmap; import android.util.SparseArray; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.TextView; import com.example.zhy_baseadapterhelper.ImageLoader.Type; public class ViewHolder &#123; private final SparseArray&lt;View&gt; mViews; private int mPosition; private View mConvertView; private ViewHolder(Context context, ViewGroup parent, int layoutId, int position) &#123; this.mPosition = position; this.mViews = new SparseArray&lt;View&gt;(); mConvertView = LayoutInflater.from(context).inflate(layoutId, parent, false); // setTag mConvertView.setTag(this); &#125; /** * 拿到一个ViewHolder对象 * * @param context * @param convertView * @param parent * @param layoutId * @param position * @return */ public static ViewHolder get(Context context, View convertView, ViewGroup parent, int layoutId, int position) &#123; if (convertView == null) &#123; return new ViewHolder(context, parent, layoutId, position); &#125; return (ViewHolder) convertView.getTag(); &#125; public View getConvertView() &#123; return mConvertView; &#125; /** * 通过控件的Id获取对于的控件，如果没有则加入views * * @param viewId * @return */ public &lt;T extends View&gt; T getView(int viewId) &#123; View view = mViews.get(viewId); if (view == null) &#123; view = mConvertView.findViewById(viewId); mViews.put(viewId, view); &#125; return (T) view; &#125; /** * 为TextView设置字符串 * * @param viewId * @param text * @return */ public ViewHolder setText(int viewId, String text) &#123; TextView view = getView(viewId); view.setText(text); return this; &#125; /** * 为ImageView设置图片 * * @param viewId * @param drawableId * @return */ public ViewHolder setImageResource(int viewId, int drawableId) &#123; ImageView view = getView(viewId); view.setImageResource(drawableId); return this; &#125; /** * 为ImageView设置图片 * * @param viewId * @param drawableId * @return */ public ViewHolder setImageBitmap(int viewId, Bitmap bm) &#123; ImageView view = getView(viewId); view.setImageBitmap(bm); return this; &#125; /** * 为ImageView设置图片 * * @param viewId * @param drawableId * @return */ public ViewHolder setImageByUrl(int viewId, String url) &#123; ImageLoader.getInstance(3, Type.LIFO).loadImage(url, (ImageView) getView(viewId)); return this; &#125; public int getPosition() &#123; return mPosition; &#125; &#125; 现在的MainActivity只需要这么写： 12345678910[java] view plain copymAdapter = new CommonAdapter&lt;String&gt;(getApplicationContext(), R.layout.item_single_str, mDatas) &#123; @Override protected void convert(ViewHolder viewHolder, String item) &#123; viewHolder.setText(R.id.id_tv_title, item); &#125; &#125;; convertView里面只要一行代码了 好了，到此我们的通用的Adapter已经一步一步铸造完毕~咋样，以后写项目省下来的时间是不是可以陪我切磋dota了（ps:11昵称：血魔哥404）~~ 注：关于ViewHolder里面的setText，setImageResource这类的方法，大家可以在使用的过程中不断的完善，今天发现这个控件可以这么设置值，好，放进去；时间长了，基本就完善了。还有那个ImageLoader是我另一篇博客里的，大家可以使用UIL，Volley或者自己写个图片加载器； 7、实践说了这么多，还是得拿出来让我们的实践检验检验，顺便来几张套图，俗话说，没图没正相。 1、我们的实例代码的图是这样的： 关于Adapter和ViewHolder的代码是这样的：123456789101112[java] view plain copy// 设置适配器 mListView.setAdapter(mAdapter = new CommonAdapter&lt;String&gt;( getApplicationContext(), mDatas, R.layout.item_single_str) &#123; @Override public void convert(ViewHolder helper, String item) &#123; helper.setText(R.id.id_tv_title,item); &#125; &#125;); 哎哟，我是不是只要贴一行；2、来个复杂点的布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[html] view plain copy&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#ffffff&quot; android:orientation=&quot;vertical&quot; android:padding=&quot;10dp&quot; &gt; &lt;TextView android:id=&quot;@+id/tv_title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:singleLine=&quot;true&quot; android:text=&quot;红色钱包&quot; android:textSize=&quot;16sp&quot; android:textColor=&quot;#444444&quot; &gt; &lt;/TextView&gt; &lt;TextView android:id=&quot;@+id/tv_describe&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/tv_title&quot; android:layout_marginTop=&quot;10dp&quot; android:maxLines=&quot;2&quot; android:minLines=&quot;1&quot; android:text=&quot;周三早上丢失了红色钱包，在食堂二楼&quot; android:textColor=&quot;#898989&quot; android:textSize=&quot;16sp&quot; &gt; &lt;/TextView&gt; &lt;TextView android:id=&quot;@+id/tv_time&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/tv_describe&quot; android:layout_marginTop=&quot;10dp&quot; android:text=&quot;20130240122&quot; android:textColor=&quot;#898989&quot; android:textSize=&quot;12sp&quot; &gt; &lt;/TextView&gt; &lt;TextView android:id=&quot;@+id/tv_phone&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_below=&quot;@id/tv_describe&quot; android:layout_marginTop=&quot;10dp&quot; android:background=&quot;#5cbe6c&quot; android:drawableLeft=&quot;@drawable/icon_photo&quot; android:drawablePadding=&quot;5dp&quot; android:paddingBottom=&quot;3dp&quot; android:paddingLeft=&quot;5dp&quot; android:paddingRight=&quot;5dp&quot; android:paddingTop=&quot;3dp&quot; android:text=&quot;138024249542&quot; android:textColor=&quot;#ffffff&quot; android:textSize=&quot;12sp&quot; &gt; &lt;/TextView&gt; &lt;/RelativeLayout&gt; ` 效果图是这样的： 布局是不是挺复杂的了~~ 但是代码是这样的：1234567891011121314151617[java] view plain copy// 设置适配器 mListView.setAdapter(mAdapter = new CommonAdapter&lt;Bean&gt;( getApplicationContext(), mDatas, R.layout.item_list) &#123; @Override public void convert(ViewHolder helper, Bean item) &#123; helper.setText(R.id.tv_title, item.getTitle()); helper.setText(R.id.tv_describe, item.getDesc()); helper.setText(R.id.tv_phone, item.getPhone()); helper.setText(R.id.tv_time, item.getTime()); // helper.getView(R.id.tv_title).setOnClickListener(l) &#125; &#125;); 从一个字符串的布局到这样的布局，Adapter加ViewHolder的改变就这么多，加起来3行左右代码~~~ 到此，Android 快速开发系列 打造万能的ListView GridView 适配器结束； 最后给大家推荐一个gitHub项目：https://github.com/JoanZapata/base-adapter-helper ,这个项目所做的，和我上面写的基本一致。 还有上面的布局文件来自网络，感谢Bmob的提供~ 好了，我要去快乐的玩耍了~~ 以下为最新更新==&gt; 添加了多种Item类型的支持，源码地址：https://github.com/hongyangAndroid/base-adapter .","tags":[]},{"title":"Collections.sort对数组进行排序","date":"2018-06-15T05:51:52.000Z","path":"2018/06/15/Collections-sort对数组进行排序/","text":"1234567891011121314151617181920212223Collections.sort(countType, new Comparator&lt;Map&lt;String, String&gt;&gt;() &#123; @Override public int compare(Map&lt;String, String&gt; o1, Map&lt;String, String&gt; o2) &#123; String occupy1 = o1.get(&quot;occupy&quot;); String substring1 = occupy1.substring(occupy1.indexOf(&quot;&#123;&quot;) + 1, occupy1.length() - 1); String occupy2 = o2.get(&quot;occupy&quot;); String substring2 = occupy2.substring(occupy2.indexOf(&quot;&#123;&quot;) + 1, occupy2.length() - 1); int m1 = Integer.parseInt(substring1); int m2 = Integer.parseInt(substring2); if (m1 &gt; m2) &#123; //m1在m2后面 return 1; &#125; else if (m1 &lt; m2) &#123; //m1在m2前面 return -1; &#125; else &#123; Toast.makeText(FYInspecRequireActivity.this, &quot;返回数据存在问题，occupy有相同的，我无法解析&quot;, Toast.LENGTH_SHORT).show(); return 0; &#125; &#125;&#125;);","tags":[]},{"title":"Java7新特性","date":"2018-06-15T05:46:16.000Z","path":"2018/06/15/Java7新特性/","text":"float pi1 = 3_.1415F; // 无效的; 不能在小数点之前有下划线float pi2 = 3._1415F; // 无效的; 不能在小数点之后有下划线long socialSecurityNumber1 = 999_99_9999_L; //无效的，不能在L下标之前加下划线int a1 = _52; // 这是一个下划线开头的标识符，不是个数字int a2 = 52; // 有效int a3 = 52; // 无效的，不能以下划线结尾int a4 = 5___2; // 有效的int a5 = 0_x52; // 无效，不能在0x之间有下划线int a6 = 0x_52; // 无效的，不能在数字开头有下划线int a7 = 0x52; // 有效的 (16进制数字)int a8 = 0x52; // 无效的，不能以下划线结尾int a9 = 0_52; // 有效的（8进制数）int a10 = 052; // 有效的（8进制数）int a11 = 052; // 无效的，不能以下划线结尾 long creditCardNumber = 6684_5678_9012_3456L; // 在编码的时候，最好永远不要这么做long socialSecurityNumber = 333_99_9999L; // 在编码的时候，最好永远不要这么做float pi = 3.14_15F;long hexBytes = 0xFF_EC_DE_5E;long hexWords = 0xCAFE_BABE;long maxLong = 0x7fff_ffff_ffff_ffffL;byte nybbles = 0b0010_0101;long bytes = 0b11010010_01101001_10010100_10010010;","tags":[]},{"title":"webview属性使用大全","date":"2018-05-30T23:40:40.000Z","path":"2018/05/31/webview属性使用大全/","text":"WebViewWebSettings settings = webView.getSettings();//获取webview的设置settings.setJavaScriptEnabled(true);//可以加载jssettings.setPluginState(WebSettings.PluginState.ON);////让WebView支持播放插件webView.setWebChromeClient(new WebChromeClient());//页面标题与页面中连接跳转的处理if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) { settings.setMediaPlaybackRequiresUserGesture(false);//设置WebView是否通过手势触发播放媒体，默认是true，需要手势触发。}//设置WebView是否使用viewport，// 当该属性被设置为false时，加载页面的宽度总是适应WebView控件宽度；当被设置为true，// 当前页面包含viewport属性标签，在标签中指定宽度值生效，如果页面不包含viewport标签，// 无法提供一个宽度值，这个时候该方法将被使用。webView.getSettings().setUseWideViewPort(true);webView.getSettings().setLoadWithOverviewMode(true);// webView.getSettings().setDomStorageEnabled(true);// webView.getSettings().setSupportMultipleWindows(true);webView.setWebChromeClient(new WebChromeClient());// webView.setWebViewClient(new WebViewClient());// webView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);.//开启硬件加速webView.getSettings().setLoadWithOverviewMode(true);//设置WebView是否使用预览模式加载界面。webView.getSettings().setDomStorageEnabled(true);//设置是否开启DOM存储API权限，默认false，未开启，设置为true，WebView能够使用DOM storage APIsettings.setAllowFileAccess(true);//设置在WebView内部是否允许访问文件settings.setAppCacheEnabled(true);//是否使用应用缓存// webView.getSettings().setSupportMultipleWindows(true);//设置WebView是否支持多屏窗口，参考WebChromeClient#onCreateWindow，默认false，不支持。// webView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);.//关闭单个view的硬件加速","tags":[]},{"title":"儿时味道","date":"2018-05-22T05:19:53.000Z","path":"2018/05/22/儿时味道/","text":"小时候的味道谈起来终于说不完的思念别人家的总是好吃 开春去干涸的沟中找那种草牙,嚼着真香 夏天自己抓得鱼,自己烤着吃,然后吃得满嘴黑乎乎的,那是那个鲜香. 秋天偷着人家的地瓜,找个桥东烤着吃,那叫一个美味 冬天去挖人家埋在地里的萝卜,冻得瑟瑟发抖,当时也是感觉很不错 自家的味道也是不错的 奶奶做的咸菜总是有吃不够的感觉 妈妈晒的红薯味道就是不一样 还有那碗自己扛的苗条","tags":[]},{"title":"部分android手机拍照完图片旋转问题处理","date":"2018-05-22T01:34:17.000Z","path":"2018/05/22/部分android手机拍照完图片旋转问题处理/","text":"部分android手机拍完照片,读取出来照片被旋转问题今天测试时发现小米6手机拍照时显示返回的照片显示被旋转90度,华为手机显示正常. 思路:使用Camera拍照以后，得到的照片会被自动旋转（90°、180°、270°），这个情况很不符合预期。仔细分析了一下，因为照片属性中是存储了旋转信息的，所以要解决这个问题，可以在onActivityResult方法中，获取到照片数据后，读取它的旋转信息，如果不是0，说明这个照片已经被旋转过了，那么再使用android.graphics.Matrix将照片旋转回去即可。 ExifInterface(包含相片相关信息)获取,根据这个角度旋转就能获得我们想要的方向 1、读取图片的旋转属性123456789101112131415161718192021222324252627282930/** * 读取图片的旋转的角度 * * @param path 图片绝对路径 * @return 图片的旋转角度 */private int getBitmapDegree(String path) &#123; int degree = 0; try &#123; // 从指定路径下读取图片，并获取其EXIF信息 ExifInterface exifInterface = new ExifInterface(path); // 获取图片的旋转信息 int orientation = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL); switch (orientation) &#123; case ExifInterface.ORIENTATION_ROTATE_90: degree = 90; break; case ExifInterface.ORIENTATION_ROTATE_180: degree = 180; break; case ExifInterface.ORIENTATION_ROTATE_270: degree = 270; break; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return degree;&#125; 2、将图片按照某个角度进行旋转1234567891011121314151617181920212223242526/** * 将图片按照某个角度进行旋转 * * @param bm 需要旋转的图片 * @param degree 旋转角度 * @return 旋转后的图片 */ public static Bitmap rotateBitmapByDegree(Bitmap bm, int degree) &#123; Bitmap returnBm = null; // 根据旋转角度，生成旋转矩阵 Matrix matrix = new Matrix(); matrix.postRotate(degree); try &#123; // 将原始图片按照旋转矩阵进行旋转，并得到新的图片 returnBm = Bitmap.createBitmap(bm, 0, 0, bm.getWidth(), bm.getHeight(), matrix, true); &#125; catch (OutOfMemoryError e) &#123; &#125; if (returnBm == null) &#123; returnBm = bm; &#125; if (bm != returnBm) &#123; bm.recycle(); &#125; return returnBm; &#125; 3 应用在onActivityResult中,首先根据图片URL获取旋转角度信息,然后将返回的bitmap 旋转相应的角度. 完美结束 为尊重原创,特此感谢Alienl","tags":[{"name":"android 拍照","slug":"android-拍照","permalink":"http://yoursite.com/tags/android-拍照/"}]},{"title":"一个android应用的从无到有01","date":"2017-12-26T00:44:32.000Z","path":"2017/12/26/一个android应用的从无到有/","text":"需求： 参考：wifi管家，架构我们自己控制累应用。 （领导说话就这样，一句话剩下的是需求拆解） 需求分析： 首先wifi管家，分为三个内容板块，另加一个个人中心。 (首页)第一个内容中心主要是：设备控制类/体验为主 第二个内容中心主要是：设备绑定，一键链接 第三个内容中心主要是：新闻咨询 首页右上角，是个人中心的入口根据需求选择合适的开发框架通过整体布局可以看到，整体可采用三个。 开发框架的选择:MVC MVP MVVM;MVC简单易上手、MVP MVVM比较绕不建议新手使用。 权衡是否使用开源的框架，还是自己写？开源的简单看懂文档就可以直接拿来用，可能有很多功能用不上。自己写建议用到什么写什么自己掌控。 这里我先尝试使用：使用之前建议现将代码demo熟悉过来 ThinkAndroid框架项目地址：https://github.com/white-cat/ThinkAndroid主要有以下模块： (1) MVC模块：实现视图与模型的分离。 (2) ioc模块：android中的ioc模块，完全注解方式就可以进行UI绑定、res中的资源的读取、以及对象的初始化。 (3) 数据库模块：android中的orm框架，使用了线程池对sqlite进行操作。 (4) http模块：通过httpclient进行封装http数据请求，支持异步及同步方式加载。 (5) 缓存模块：通过简单的配置及设计可以很好的实现缓存，对缓存可以随意的配置 (6) 图片缓存模块：imageview加载图片的时候无需考虑图片加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象。 (7) 配置器模块：可以对简易的实现配对配置的操作，目前配置文件可以支持Preference、Properties对配置进行存取。 (8) 日志打印模块：可以较快的轻易的是实现日志打印，支持日志打印的扩展，目前支持对sdcard写入本地打印、以及控制台打印 (9) 下载器模块:可以简单的实现多线程下载、后台下载、断点续传、对下载进行控制、如开始、暂停、删除等等。 (10) 网络状态检测模块：当网络状态改变时，对其进行检 框架确定好了，根据需求依赖，看看有没有开源的库和动画与需求匹配（当然可能准备的最后用不上，哈哈哈）NotBoringActionBar项目地址：https://github.com/flavienlaurent/NotBoringActionBar 由于人力变动等，外力条件该项目暂时搁置。 再次启动时间无限期推迟。","tags":[]},{"title":"Androud+H5混合开发","date":"2017-12-04T06:58:04.000Z","path":"2017/12/04/Androud-H5混合开发/","text":"","tags":[]},{"title":"记录：宝宝出生记","date":"2017-12-04T00:54:25.000Z","path":"2017/12/04/记录：宝宝出生记/","text":"我当爹了 2017年11月23日喜得贵子。 与儿子的第一眼12345678910111213下午两点半左右我的爱人推进手术室，我与家人在手术室外焦急的等待。当手术室打开推出婴儿车的那个瞬间我的眼睛模糊了。可能因为激动血压升高瞬间世界变得模糊了。医生简单介绍了一下我儿子的情况，让我签字，具体签的是什么都没来得及看。宝宝睁着眼看着陌生的世界，这是我与他的第一眼。奶奶及小姨将宝宝推走啦。（擦洗，疫苗。。。）我站在手术室外心里的喜悦无法表达，拿起手机将这喜讯让世界知道。第一个电话打给了百里之外的老爸，告诉他我也当爸爸了，你当爷爷了。。。隔着电话也能听到远方老爸也是异常的高兴，一个劲的说好挺好大约一个小时之后手术室的门再次打开，筋疲力尽的爱人推出来时这时我的眼湿润了。她是好样的，脸上一点血色也没有，隐约中能感到她的疼。 宝宝离开身边的第一晚123456789101112131415161718作为黄种人,小孩出身都会有黄疸.我也是因为孩子生黄疸去学习的,我记得我们黄种人有那么两三个特性.其他的自己去百度吧我也记清楚了.出生第3天 黄疸达到10.几 医生建议进新生儿重症监护 当时考虑孩子 犹豫再三还是去了 我们在的医院虽是三甲医院当时没有母婴同室,需要婴儿单独隔离在儿科那边.他妈在产科毕竟刚生产完.刚跟孩子见面就面临分离...隔离的这段时间 只有每天上午 10 点 可以去询问病情及前一天的情况.(不能看孩子)分离第一天晚上我们俩哭了,并彼此相互安慰...---第3天: 10.04 观察第四天: 14.2 照紫外线 抗生素第五天: 12,3 观察 抗生素第六天; 11:8 观察 抗生素第七天:10.1 观察 宝宝出院回家123456789101112131415161718第七天 他妈出院了孩子还需要观察就继续留在医院了...第八天 实在是忍不住了 加上 孩子的黄疸已经下来了我们决定强制出院,在医生的免责责任书上签字 把孩子带回来了.每天 定期晒太阳 三天 一洗澡每周 去医院测一次黄疸第一个周 去测 9第二周 10在满月的时候还是有点高 9开始打预防针的时候还是有点高 不建议打 到了一个半月 我们的才下来 7从此能吃能喝的 比我们大一个月的 长的高 张的重现在已经六个月了 74com 了","tags":[{"name":"宝宝记录","slug":"宝宝记录","permalink":"http://yoursite.com/tags/宝宝记录/"}]},{"title":"成为代码大神的必备素养","date":"2017-11-21T15:14:30.000Z","path":"2017/11/21/成为代码大神的必备素养/","text":"最近几年的android编程感悟与经验现总结一下，看大家有没有类似感受。这里主要我主要是抛个砖，有玉的尽管上哈…… 1.客户端的功能逻辑不难,UI界面也不难,但写UI花的时间是写功能逻辑的两倍. 2.写代码前的思考过程非常重要,即使在简单的功能,也需要在本子上把该功能的运行过程写出来.（找到自己最适合的思维模型创建软件） 3.要有自己的知识库,可以是一个工具类,把写过的,看过的好的代码放进去,也可以是一个笔记本软件.因为只有放在知识库里的东西,才是你最重要的财富.（创建自己的类库） 4.如果你想做自由职业者,你需要学英语,因为在国外的盈利比国内多很多.如果你想进大公司,好公司,你需要学英语.你想深入学习android,但中文的android文章太少了,你查查百度,到处都是copy来copy去的hellword,所以,你需要学英语.如果你想出国,你需要学英语.（重视英语学习） 5.Http协议要研究透彻.http的信息头有什么信息,分别代表什么,信息体有什么信息,代表什么,都要搞的明明白白.scoket也是一样.（通透http协议） 6.在eclipse里的layout文件都有graphical Layout.通过这个好好的把UI调整好(完整的UI框架). 7.Android里的junit每次运行都会打包新的apk到设备上跑.效率非常慢.如果是跟android无关的测试,最好自己建立一个单纯的java项目做测试. 8.面试的时候不要觉得自己提的薪水太高,物以稀为贵明白吗?不管你的期望薪资多少,都有可能实现,这只是时间问题. 9.如果一家小公司通过猎头找到你,即使公司在小,也比外面那些40,50人的公司还要好.不要觉得公司不行,担心会倒闭.放心吧,至少活1年是没问题的. 10.不要把自己绑在android上,有空也研究下IOS(最近小弟就准备研究ios,刚买了6本书…). 11.移动互联网最少还有10年的快速增长.android最少还有两年的快速增长.走android这条路是不会错的.(adnroid 内核) 12.有空多学点开放平台的SDK.比如新浪微博,腾讯微博,淘宝平台,支付宝移动支付平台,快钱移动支付平台等等..这些都是不愁没市场的. 13.即使技术再差,也要发布一个应用到market上去.因为这样你才了解做一个应用的逻辑. 14.每个月拿到薪水省500-1000元出来.这些钱投在买学习资料,去培训班上课…在培训班,花再多的钱也是值得的. 15.你真正的价值在项目经验和对底层的认识上.不要忽略基础知识.（java基础，快捷键的使用） 16.如果有空把Android的源代码看一下.底层的东西很枯燥,但这些很值得学. 17.程序员其实是艺术家.代码重构和设计模式,是非常非常重要的东西,必须要学 18.不要去维护一个项目,要去做一个项目.19.一开始不要轻易去大公司,虽然大公司是可以让你呆一辈子的.但你的起点低,以后成就也低. 20.每天早上提前20分钟上班,5分钟把今天的工作计划写好.15分钟用来看各大It论坛的新闻. 21.如果以前没做过java,那就把SSH看下,自己搭建一个小服务器.这是为了接私活用. 22.PS一定要学,接私活用. 23.多下载市面上好的应用,每天都用,只有这样你才能了解市场.现在所有的APK都可以反编译,看源代码麻烦,但看layout和图片很容易,所以….你懂的. 24.要有羞耻心. 25.老板仅仅要求你把东西做完,需求完成.但你必须对自己要更严格一点.写一段代码,从网上复制一份代码,并不是可以用就行了,你还必须明白他的原理,为什么这样就可以?这才是对你最有用的地方,这也是你今后薪资增长的保证. 26.要懂得舍得.移动领域发展太快,必要时必须要用钱换时间.不然你会远远落后别人(我之前花了4000大洋去培训班学IOS三天). 27.要明白自己想要什么,什么才能最大性价比提高你的能力.对我来说,能让我提高最大的,就是Android和IOS同时会,并且自己可以做架构设计.28.看android技术书籍最快的学习方法,先通读一次.然后把书本上的demo一个一个写出来.不要觉得太容易不去写.很多东西都是这样,看起来简单,但做起来难.最后再对照自己写出来的程序代码去理解书本的意思. 29.应用和游戏是2个方向,没有一个公司会同时做游戏又做应用,即使是外包公司,大多也只做一块.专精一个就可以了. 31.去中小公司面试的时候,要问两个问题,第一有没有财务部,如果有正式财务部,那肯定是正规的,不要担心欠薪问题.如果没有,就说不准了.第二,有没有测试人员,如果没有说明不规范.对项目来说,测试人员是非常重要的,是项目质量的保证. 32.大家拿到offer后都希望能看看是否还有更好的机会,这没错,但是要注意offer的有效期.一般中小公司的耐心只有一周. 33.自学的效率总是低于做项目的学习效率.这是因为没有驱动.所以如果工作很闲,那自己就去接私活,或者自己做一个应用发布出去.利益的驱动会让你进步更快. 34.Android的api涉及到很多方面.很多知识只要不用,不复习就会慢慢消失.所以每隔一段时间的总结和复习是非常必要的.建议每个月必须进行一次不短与1小时的复习. 35.如果2-3年以后你还是一线程序员,那对你来说最重要的不是技术的提高,而是身体健康的提高.建议工作2年后,有点余钱要投到健身上. 36.人的关注力总是会起伏不定.一个项目,或者一个学习目标,在坚持一段时间以后总是会松懈,偷懒.避免这种情况的最好的办法,就是隔一段时间内做总结.比如三天,或一周. 37.主要有1年以上的工作经验,大家都可以成为架构师.即使是小型的移动app,如果事先写好简单的架构设计,会让你轻松很多.这种效率等同于我之前所说的”写代码前思考过程很重要”. 38.要养成正规的编码习惯,如果公司没有编码规范,那最好写一个自己用的Android编码规范. 39.代码复用和重构是非常必要的习惯.但这只是针对非业务逻辑,如果是业务逻辑,那就尽量少复用. 40.周末没事就去参加一些免费的沙龙,讲座,一来拓展下知识面,二来认识更多的人,程序员每天一直呆在公司,仅仅透过网络你无法深刻感触外在世界的变化.顺便说一下,貌似很多老板都是在这里找到优秀员工的.你所要付出的仅仅是路费. 41.每两个月啃掉一本书并不是很难的事情. 42.如果工作很轻松很闲,那你要加紧把握现在这个机会.每天给你钱让自己去学习的机会很少很少. 43.如果把程序员比做工地建筑工人,技术领头人比作包工头,架构师比作建筑师.那么当你写代码前不做任何思考的时候,那你就是建筑工人.当你有意识的把代码规范,设计模式这些东西运用到项目中,并严格遵守游戏规则,那你就是包工头.当你开始制定游戏规则,开始考虑到产品使用者,产品生产者等各种涉众的利益的时候,那你就是建筑师. 45.人的信心是非常强大的力量.自不量力的人比量力而行的人成就更高. 46.代码是否优美,是否整洁是难定义的.我的一个简单的量化标准是,一个类代码在600行以下就可以了 47.你要有这样的觉悟,项目出了任何问题,都是你的责任!没判断null?那是你的错.图片切错了?那是你的错,产品上线不了?那是你的问题,产品销售不给力?那是你的问题.你必须学会要用一种积极向上的思维方式来看待这个世界.任何问题,都是你的错.","tags":[{"name":"素养","slug":"素养","permalink":"http://yoursite.com/tags/素养/"}]},{"title":"Hexo 常用指令","date":"2017-11-21T15:02:58.000Z","path":"2017/11/21/Hexo-常用指令/","text":"hexo cleanhexo generatehexo deploy 一些常用命令： hexo new”postName” #新建文章 hexo new page”pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 参考链接：http://www.jianshu.com/p/465830080ea9 遇到问题一: Error: listen EADDRINUSE 本地服务器端口问题解决方法:hexo server -p 8000 更换端口重新试一下 在此补充一点atom快捷键：ctrl+shift+m //实时显示makedown预览","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"ubuntu 安装Node.js","date":"2017-11-21T13:38:37.000Z","path":"2017/11/21/ubuntu-安装Node-js/","text":"Ubuntu 安装Node.js 目的：Ubuntu是一个好的开发系统，非常适合开发，但是当我们配置好第一次，一般尽量很少再去修改删除了。所以有很多指令及安装方式总会忘记，这也是我的目的。 前提及原由：原来我的电脑已经将开发环境配置好，并在年前还写过几篇文章，后来来到新公司刚来没有分派配电脑，暂时用我的个人电脑因为工作需要（非开发相关德居多）所以将电脑系统重装回Windows。公司配置de电脑到位后就将我电脑重新换回Ubuntu，一直没时间倒腾甚至连基本德更新都很少使用。 sudo apt-get update 过程:今天准备配置hexo的时候发现的update竟然会报错如下，问了下度娘顺利解决 错误： E:Encountered a section with no Package: header 解决方式： sudo rm /var/lib/apt/lists/* -vf sudo apt-get update npm 和 node 我发现之前不知道什么时候装过直接上来就 sudo npm install -g hexo 发现试了好几遍都不行. ERROR: npm is known not to run on Node.js v4.4.3 那这个运行不了node我就心思,要不是npm的问题就是node的问题.奶奶个熊的我就不信了…npm 好说,装个其他软件试试就知道,node难就在这官网提供的是个tar包也不知道咋想得,看着就头疼.下载下来解压了发现也没什么卵用. 废话说这么多开始上干活:选择一个目录,用git下载node源码 git clone https://github.com/nodejs/node 修改clone下来的node文件夹读写权限 sudo chmod -R 777 node个人习惯使用777,实际755就足够了,为了防止再次修改我一般都会777cd nodesudo ./configure //加载makefile文件sudo make //编译(实际时间比较长).后面可以接-j8表示开线程数,make -j8表示开8个线程去编译sudo make install//安装 如果人品好,一切结束就算完成,人品不好像我可能还会遇到一些问题.编译过程中报错了怎么办.不好意思,我没保存我的错误log.其实当时我也没看懂.我的处理方式分两部,首先删除out已经编译内容重新编译一遍.发现还是有问题,然后我发下我的路径竟然有中文(我在”下载”目录下)将我的node目录移至home根目录下重新来遍 ok没问题…","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}]},{"title":"Eclipse快捷键","date":"2017-09-13T01:56:56.021Z","path":"2017/09/13/Eclipse快捷键/","text":"1. ctrl+shift+r：打开资源这可能是所有快捷键组合中最省时间的了。这组快捷键可以让你打开你的工作区中任何一个文件，而你只需要按下文件名或mask名中的前几个字母，比如applic*.xml。美中不足的是这组快捷键并非在所有视图下都能用。 2. ctrl+o：快速outline如果想要查看当前类的方法或某个特定方法，但又不想把代码拉上拉下，也不想使用查找功能的话，就用ctrl+o吧。它可以列出当前类中的所有方法及属性，你只需输入你想要查询的方法名，点击enter就能够直接跳转至你想去的位置。 3. ctrl+e：快速转换编辑器这组快捷键将帮助你在打开的编辑器之间浏览。使用ctrl+page down或ctrl+page up可以浏览前后的选项卡，但是在很多文件打开的状态下，ctrl+e会更加有效率。 4. ctrl+2，L：为本地变量赋值开发过程中，我常常先编写方法，如Calendar.getInstance()，然后通过ctrl+2快捷键将方法的计算结果赋值于一个本地变量之上。 这样我节省了输入类名，变量名以及导入声明的时间。Ctrl+F的效果类似，不过效果是把方法的计算结果赋值于类中的域。 5. alt+shift+r：重命名重命名属性及方法在几年前还是个很麻烦的事，需要大量使用搜索及替换，以至于代码变得零零散散的。今天的Java IDE提供源码处理功能，Eclipse也是一样。现在，变量和方法的重命名变得十分简单，你会习惯于在每次出现更好替代名称的时候都做一次重命名。要使 用这个功能，将鼠标移动至属性名或方法名上，按下alt+shift+r，输入新名称并点击回车。就此完成。如果你重命名的是类中的一个属性，你可以点击alt+shift+r两次，这会呼叫出源码处理对话框，可以实现get及set方法的自动重命名。 6. alt+shift+l以及alt+shift+m：提取本地变量及方法源码处理还包括从大块的代码中提取变量和方法的功能。比如，要从一个string创建一个常量，那么就选定文本并按下alt+shift+l即可。如果同 一个string在同一类中的别处出现，它会被自动替换。方法提取也是个非常方便的功能。将大方法分解成较小的、充分定义的方法会极大的减少复杂度，并提 升代码的可测试性。 7. shift+enter及ctrl+shift+enterShift+enter在当前行之下创建一个空白行，与光标是否在行末无关。Ctrl+shift+enter则在当前行之前插入空白行。 8. Alt+方向键这也是个节省时间的法宝。这个组合将当前行的内容往上或下移动。在try/catch部分，这个快捷方式尤其好使。 9. ctrl+m大显示屏幕能够提高工作效率是大家都知道的。Ctrl+m是编辑器窗口最大化的快捷键。 10. ctrl+.及ctrl+1：下一个错误及快速修改ctrl+.将光标移动至当前文件中的下一个报错处或警告处。这组快捷键我一般与ctrl+1一并使用，即修改建议的快捷键。新版Eclipse的修改建 议做的很不错，可以帮你解决很多问题，如方法中的缺失参数，throw/catch exception，未执行的方法等等。 更多快捷键组合可在Eclipse按下ctrl+shift+L查看。 让我们按照使用频率来看看我最爱用的一些热键组合。（注：以下内容在Eclipse3.02及一上版本通过测试） Control-Shift-T: 打开类型（Open type）。如果你不是有意磨洋工，还是忘记通过源码树（source tree）打开的方式吧。用eclipse很容易打开接口的实现类的，按ctrl+t会列出接口的实现类列表 Control-Shift-R: 打开资源（不只是用来寻找Java文件）。小提示：利用Navigator视图的黄色双向箭头按钮让你的编辑窗口和导航器相关联。这会让你打开的文件对应显示在导航器的层级结构中，这样便于组织信息。如果这影响了速度，就关掉它。 F3: 打开申明（Open declaration）。或者，利用Declaration Tab（在Java视图模式下，选择Windows –&gt; Show View – &gt; Declaration）。当你选中代码中的一个方法，然后按这个按键，它会把整个方法在申明方框里显示出来。 Alt-left arrow: 在导航历史记录（Navigation History）中后退。就像Web浏览器的后退按钮一样，在利用F3跳转之后，特别有用。（用来返回原先编译的地方） Alt-right arrow: 导航历史记录中向前。 Control-Q: 回到最后一次编辑的地方。这个快捷键也是当你在代码中跳转后用的。特别是当你钻的过深，忘记你最初在做什么的时候。 Control-Shift-G: 在workspace中搜索引用（reference）。这 是重构的前提。对于方法，这个热键的作用和F3恰好相反。它使你在方法的栈中，向上找出一个方法的所有调用者。一个与此相关的功能是开启“标记”功能 （occurrence marking） 。选择Windows-&gt;Preferences-&gt;Java-&gt; Editor-&gt; Mark Occurrences，勾选选项。这时，当你单击一个元素的时候，代码中所有该元素存在的地方都会被高亮显示。我个人只使用“标记本地变量”（Mark Local Variables）。注意：太多的高亮显示会拖慢Eclipse。 Control-Shift-F: CodeàJavaàPreferencesà根据代码风格设定重新格式化代码。我 们的团队有统一的代码格式，我们把它放在我们的wiki上。要这么做，我们打开Eclipse，选择Window Style，然后设置Code Formatter，Code Style和Organize Imports。利用导出（Export）功能来生成配置文件。我们把这些配置文件放在wiki上，然后团队里的每个人都导入到自己的Eclipse中。 Control-O: 快速概要(quick outline)。通过这个快捷键，你可以迅速的跳到一个方法或者属性，只需要输入名字的头几个字母。 Control-/: 对一行注释或取消注释。对于多行也同样适用。 Control-Alt-down arrow: 复制高亮显示的一行或多行。 Alt-down arrow: 将一行或多行向下移动。Alt-up arrow会向上移动。 其他的热键在菜单里有。你可以通过按下Control-Shift-L（从3.1版本开始）， 看到所有快捷键的列表。按下Control-Shift-L两次，会显示热键对话框（Keys Preferences dialog），你可以在这里自己设置热键。我欢迎你在Talkback部分发表你的Eclipse提示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272其他的Eclipse窍门我总结了几个相关的小窍门：锁定命令行窗口：在命令行视图中（Window -&gt;Show View -&gt;Other -&gt;Basic -&gt;Console），试试看用滚动锁定按钮来锁定控制台输出不要滚屏。使用Ant视图： 在我的Java或Debug模式下，我喜欢显示出Ant视图，这样我就可以迅速的运行Ant任务。通过Window Ant可以找到该视图。把Ant视图放在屏幕的一角， 通过“添加编译文件（Addà Other à Show View à Buildfiles）”按钮来添加build.xml文件。在3.1版本中，甚至支持Ant调试脚本语言。自动遍历一个集合：for + Control-Space: 如果你还不知道，那么你应该记住Control-Space是自动完成功能。在Eclipse中，你还可以自动完成结构。在一个数组或集合范围内，试试看 输入“for”然后按下Control-Space键。Eclipse会问你你想要遍历哪一个集合然后自动完成循环代码。使用分级布局： 在包浏览视图（Package Explorer view）中默认的布局（扁平式）方式让我困惑，它把包的全名显示在导航树（navigation tree）中。我更喜欢我源码的包和文件系统视图，在Eclipse中叫做分级布局（Hierarchical Layout）。要切换到这种模式，点击包浏览视图中向下的按钮，选择布局（Layout），然后选择分级（Hierarchial）。一次显示多个文件：你可以一次浏览多个文件。把不在激活状态的编辑窗口拖到激活窗口的底部或侧边的滚动条上，就可以打开该编辑窗口。这是我能描述该窍门的最好方式了。同时打开两个Eclipse： 要将改动从一个CVS分支上合并到另外一个上，我喜欢通过同时打开两个工作目录（Workspace）不同Eclipse来实现。这样我可以通过比较 CVS上的最新版本看到所有的变化（右键单击工程，然后选择Compare Lastest from HEAD）然后把每一个变化都合并到另外一个CVS分支上。启动多个Eclipse的最简单的方法是利用Eclipseàwith Launcher。Implementors插件：安装一个能够跳到一个接口的实现的插件。如果你是个dependency injection 粉丝，或者正在基于编写优良的接口工作，那么你需要一个这样的插件来加速代码导航。 你可以在SourceForge找到这个插件。Ctrl+Alt+H如果你想知道一个类的方法到底被那些其他的类调用，那么请选中这个方法名，然后按“Ctrl+Alt+H”，Eclipse就会显示出这个方法被哪些方法调用，最终产生一个调用关系树。 1. Ctrl+左键这个是大多数人经常用到的，用来查看变量、方法、类的定义2. Ctrl+O查看一个类的纲要，列出其方法和成员变量。提示：再多按一次Ctrl+O，可以列出该类继承的方法和变量。助记：&quot;O&quot;---&gt;&quot;Outline&quot;---&gt;&quot;纲要&quot;3. Ctrl+T查看一个类的继承关系树，是自顶向下的，再多按一次Ctrl+T, 会换成自底向上的显示结构。提示：选中一个方法名，按Ctrl+T，可以查看到有这个同名方法的父类、子类、接口。助记：&quot;T&quot;-------&gt;&quot;Tree&quot;-----&gt;&quot;层次树&quot;4.Alt+左右方向键我们经常会遇到看代码时Ctrl+左键，层层跟踪，然后迷失在代码中的情况，这时只需要按“Alt+左方向键”就可以退回到上次阅读的位置，同理，按“Alt+右方向键”会前进到刚才退回的阅读位置，就像浏览器的前进和后退按钮一样。导入包：Ctrl+Shift+O 编辑 作用域 功能 快捷键 全局 查找并替换 Ctrl+F 文本编辑器 查找上一个 Ctrl+Shift+K 文本编辑器 查找下一个 Ctrl+K 全局 撤销 Ctrl+Z 全局 复制 Ctrl+C 全局 恢复上一个选择 Alt+Shift+↓ 全局 剪切 Ctrl+X 全局 快速修正 Ctrl1+1 全局 内容辅助 Alt+/ 全局 全部选中 Ctrl+A 全局 删除 Delete 全局 上下文信息 Alt+？ Alt+Shift+? Ctrl+Shift+Space Java编辑器 显示工具提示描述 F2 Java编辑器 选择封装元素 Alt+Shift+↑ Java编辑器 选择上一个元素 Alt+Shift+← Java编辑器 选择下一个元素 Alt+Shift+→ 文本编辑器 增量查找 Ctrl+J 文本编辑器 增量逆向查找 Ctrl+Shift+J 全局 粘贴 Ctrl+V 全局 重做 Ctrl+Y 查看 作用域 功能 快捷键 全局 放大 Ctrl+= 全局 缩小 Ctrl+- 窗口 作用域 功能 快捷键 全局 激活编辑器 F12 全局 切换编辑器 Ctrl+Shift+W 全局 上一个编辑器 Ctrl+Shift+F6 全局 上一个视图 Ctrl+Shift+F7 全局 上一个透视图 Ctrl+Shift+F8 全局 下一个编辑器 Ctrl+F6 全局 下一个视图 Ctrl+F7 全局 下一个透视图 Ctrl+F8 文本编辑器 显示标尺上下文菜单 Ctrl+W 全局 显示视图菜单 Ctrl+F10 全局 显示系统菜单 Alt+- 导航 作用域 功能 快捷键 Java编辑器 打开结构 Ctrl+F3 全局 打开类型 Ctrl+Shift+T 全局 打开类型层次结构 F4 全局 打开声明 F3 全局 打开外部javadoc Shift+F2 全局 打开资源 Ctrl+Shift+R 全局 后退历史记录 Alt+← 全局 前进历史记录 Alt+→ 全局 上一个 Ctrl+, 全局 下一个 Ctrl+. Java编辑器 显示大纲 Ctrl+O 全局 在层次结构中打开类型 Ctrl+Shift+H 全局 转至匹配的括号 Ctrl+Shift+P 全局 转至上一个编辑位置 Ctrl+Q Java编辑器 转至上一个成员 Ctrl+Shift+↑ Java编辑器 转至下一个成员 Ctrl+Shift+↓ 文本编辑器 转至行 Ctrl+L 搜索 作用域 功能 快捷键 全局 出现在文件中 Ctrl+Shift+U 全局 打开搜索对话框 Ctrl+H 全局 工作区中的声明 Ctrl+G 全局 工作区中的引用 Ctrl+Shift+G 文本编辑 作用域 功能 快捷键 文本编辑器 改写切换 Insert 文本编辑器 上滚行 Ctrl+↑ 文本编辑器 下滚行 Ctrl+↓ 文件 作用域 功能 快捷键 全局 保存 Ctrl+X Ctrl+S 全局 打印 Ctrl+P 全局 关闭 Ctrl+F4 全局 全部保存 Ctrl+Shift+S 全局 全部关闭 Ctrl+Shift+F4 全局 属性 Alt+Enter 全局 新建 Ctrl+N 项目 作用域 功能 快捷键 全局 全部构建 Ctrl+B 源代码 作用域 功能 快捷键 Java编辑器 格式化 Ctrl+Shift+F Java编辑器 取消注释 Ctrl+/ Java编辑器 注释 Ctrl+/ Java编辑器 添加单个import Ctrl+Shift+M Java编辑器 组织多个import Ctrl+Shift+O Java编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。 也可以使用Ctrl+1自动修正。 调试/运行 作用域 功能 快捷键 全局 单步返回 F7 全局 单步跳过 F6 全局 单步跳入 F5 全局 单步跳入选择 Ctrl+F5 全局 调试上次启动 F11 全局 继续 F8 全局 使用过滤器单步执行 Shift+F5 全局 添加/去除断点 Ctrl+Shift+B 全局 显示 Ctrl+D 全局 运行上次启动 Ctrl+F11 全局 运行至行 Ctrl+R 全局 执行 Ctrl+U 重构 作用域 功能 快捷键 全局 撤销重构 Alt+Shift+Z 全局 抽取方法 Alt+Shift+M 全局 抽取局部变量 Alt+Shift+L 全局 内联 Alt+Shift+I 全局 移动 Alt+Shift+V 全局 重命名 Alt+Shift+R 全局 重做 Alt+Shift+Y（1）Ctrl+M切换窗口的大小 （2）Ctrl+Q跳到最后一次的编辑处 （3）F2当鼠标放在一个标记处出现Tooltip时候按F2则把鼠标移开时Tooltip还会显示即Show TooltipDescription。F3跳到声明或定义的地方。F5单步调试进入函数内部。F6单步调试不进入函数内部，如果装了金山词霸2006则要把“取词开关”的快捷键改成其他的。F7由函数内部返回到调用处。F8一直执行到下一个断点。（4）Ctrl+Pg~对于XML文件是切换代码和图示窗口（5）Ctrl+Alt+I看Java文件中变量的相关信息（6）Ctrl+PgUp对于代码窗口是打开“Show List”下拉框，在此下拉框里显示有最近曾打开的文件（7）Ctrl+/ 在代码窗口中是这种//~注释。Ctrl+Shift+/ 在代码窗口中是这种/*~*/注释，在JSP文件窗口中是〈!--~--〉。（8）Alt+Shift+O(或点击工具栏中的Toggle Mark Occurrences按钮) 当点击某个标记时可使本页面中其他地方的此标记黄色凸显，并且窗口的右边框会出现白色的方块，点击此方块会跳到此标记处。（9）右击窗口的左边框即加断点的地方选Show Line Numbers可以加行号。（10）Ctrl+I格式化激活的元素Format Active Elements。Ctrl+Shift+F格式化文件Format Document。（11）Ctrl+S保存当前文件。Ctrl+Shift+S保存所有未保存的文件。（12）Ctrl+Shift+M(先把光标放在需导入包的类名上) 作用是加Import语句。Ctrl+Shift+O作用是缺少的Import语句被加入，多余的Import语句被删除。（13）Ctrl+Space提示键入内容即Content Assist，此时要将输入法中Chinese(Simplified)IME-Ime/Nonlme Toggle的快捷键（用于切换英文和其他文字）改成其他的。Ctrl+Shift+Space提示信息即Context Information。（14）双击窗口的左边框可以加断点。（15）Ctrl+D删除当前行。Eclipse快捷键大全Ctrl+1 快速修复(最经典的快捷键,就不用多说了)Ctrl+D: 删除当前行Ctrl+Alt+↓ 复制当前行到下一行(复制增加)Ctrl+Alt+↑ 复制当前行到上一行(复制增加)Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了)Alt+↑ 当前行和上面一行交互位置(同上)Alt+← 前一个编辑的页面Alt+→ 下一个编辑的页面(当然是针对上面那条来说了)Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后)Shift+Ctrl+Enter 在当前行插入空行(原理同上条)Ctrl+Q 定位到最后编辑的地方Ctrl+L 定位在某行 (对于程序超过100的人就有福音了)Ctrl+M 最大化当前的Edit或View (再按则反之)Ctrl+/ 注释当前行,再按则取消注释Ctrl+O 快速显示 OutLineCtrl+T 快速显示当前类的继承结构Ctrl+W 关闭当前EditerCtrl+K 参照选中的Word快速定位到下一个Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示)Ctrl+/(小键盘) 折叠当前类中的所有代码Ctrl+×(小键盘) 展开当前类中的所有代码Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替)Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作)Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了)Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查)Ctrl+Shift+F4 关闭所有打开的EditerCtrl+Shift+X 把当前选中的文本全部变味小写Ctrl+Shift+Y 把当前选中的文本全部变为小写Ctrl+Shift+F 格式化当前代码Ctrl+Shift+P 定位到对于的匹配符(譬如&#123;&#125;) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)下面的快捷键是重构里面常用的,本人就自己喜欢且常用的整理一下(注:一般重构的快捷键都是Alt+Shift开头的了)Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力)Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用)Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定)Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候)Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能)Alt+Shift+I 合并变量(可能这样说有点不妥Inline)Alt+Shift+V 移动函数和变量(不怎么常用)Alt+Shift+Z 重构的后悔药(Undo) 转自（http://www.cnblogs.com/iamfy/archive/2012/07/11/2586869.html）","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://yoursite.com/tags/Eclipse/"}]},{"title":"git 常用指令","date":"2017-09-13T01:56:56.021Z","path":"2017/09/13/git常用指令/","text":"对于新手可以先去看一下廖雪峰的博客从基础去学习git指令，而我这里只是我认为比较常用重要的指令。 git clone git@github.com:XinMing-Liu/XinMing-Liu.github.io.git //克隆代码 git status 查看仓库状态git status &lt; dir &gt; 查看该仓库下某个目录的状态gitk 查看历史提交记录gitk -10 查看最近十次的提交记录git log -2 查看最近两次的提交log描述（可用gitk代替，应用场景在repo仓库中可保存每个git最后提交的记录）git branch -a(或者 -av) 查看分直结构git add . 姜本地修改提交到本地缓存git commit -m “提交描述”git commit –amend 修改上次提交的描述信息","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Android 启动过程详解","date":"2017-09-13T01:56:56.021Z","path":"2017/09/13/Android-启动过程详解/","text":"1今天系统遇到一个问题，问题描述是这样的：开机或者是重启平板的时候经常会卡在OS动画进不去系统，需要强制关机或者是按复位孔在重新开机才能进系统。 这样有机会深入了解开机的具体过程。 首先，百度了一下先关资料(如下)： Android 启动过程简介 其实这些之前也是有所了解的，不过通过这次机会可以重新认识一下。 ####详解 Android系统在启动时首先会启动Linux基础系统，然后引导加载Linux Kernel并启动初始化进程（Init），在第一个进程中会读取init.rc。在这个文件中会启动servicemanager,zygote……等基本的服务。 在init.c@system/core/init。会调用parse_config_file(init.rc)解析脚本文件init.rc init.rc一般会在devices目录下 包括系统的初始化创建文件夹，设置文件权限，初始话启动服务等都在init.rc中配置例如以下截取的部分片段：123#GPS mkdir /data/gps_mnl 0771 gps system mkdir /data/misc/gps 0770 gps system 123#bootanation 启动on property:init.svc.bootanim=runningwrite /proc/bootprof &quot;BOOT_Animation:START&quot; 1234567#wlan0初始话service dhcpcd_wlan0 /system/bin/dhcpcd -BK -dd class main user root group net_admin net_raw disabled oneshot 我这里看的是mtk中的init.rc文件。如下不同的模块的初始化可以放在相应的rc文件中1234567891011import init.project.rcimport /FWUpgradeInit.rcimport init.xlog.rcimport init.aee.rcimport init.fon.rcimport init.volte.rcimport init.mal.rcimport init.epdg.rcimport init.trustonic.rcimport init.common_svc.rcimport init.mt8173.usb.rc （在frameworks\\base\\core\\jni文件夹下存在com_android_internel_os_ZygoteInit.cpp文件。在此文件中通过register_com_android_internel_os_ZygoteInit函数调用AndroidRuntime::registerNativeMethods函数。）最终会调用到frameworks/base/core/jni/AndroidRuntime.cpp的start()方法。事实上，Android API与本地方法的注册关联就是在AndroidRuntime.cpp模块里完成的。","tags":[]},{"title":"Android SDK 目录详解","date":"2017-09-13T01:56:56.021Z","path":"2017/09/13/Android-SDK目录详解/","text":"对于整套安卓源码是个复杂的庞大的工程，我将尽我所能将所有目录及结构将明白，首先我们先来了解每个目录是做什么的。初级了解可以不必纠结android版本存在的差异，先做一次大体的了解。下边我基于android6.0来分析，以下是所有目录。1234567891011121314151617181920212223242526272829abi/art/bionic/ （bionic C库）bootable/ （启动引导相关代码）build/ 编译脚本（makefile shell（bash））cts/ （Android兼容性测试套件标准）dalvik/ 虚拟机相关工具developers/ 开发工具和例子程序源码development/ 开发工具和例子程序源码device/ 厂家目录docs/ 说明文档external/ 三方开源库代码（android使用的一些开源的模组）frameworks/ 应用框架源码gen/hardware/ 硬件抽象层源码（部分厂家开源的硬解适配层HAL代码）libcore/libnativehelper/Makefilendk/ 开发本地工具箱代码out/ 编译结果packages/ 应用程序及包的源码pdk/platform_testing/prebuilts/ （x86和arm架构下预编译的一些资源）projectFilesBackup/sdk/ 应用程序开发工具箱中工具源代码（sdk及模拟器）system/ 系统核心程序和本地服务程序源码（底层文件系统库、应用及组件——C语言）tools/vendor/ 厂家预制应用及修改原生系统源码（厂商定制代码） 这些目录，其中大部分是做安卓开发无法涉猎的，其实它也是不是我们做安卓开发所要去修改的，而是由底层ROM驱动工程师去改的。说白了就是跟我们没关系。 这里我推荐以下几个目录做重点了解：build；frameworks；external；out；packages；system；vendor；device如果你想在一款nexs上开发一套自己的全新系统了解这些足够了。（贪多吃不烂，这个道理不必多说现在开始） ######以下是我从各个网站整理的部分目录功能的介绍（了解）。123456789101112131415161718192021222324252627282930313233343536373839bionic 目录|-- libc （C库）| |-- arch-arm （ARM架构，包含系统调用汇编实现）| |-- arch-x86 （x86架构，包含系统调用汇编实现）| |-- bionic （由C实现的功能，架构无关）| |-- docs （文档）| |-- include （头文件）| |-- inet （？inet相关，具体作用不明）| |-- kernel （Linux内核中的一些头文件）| |-- netbsd （？nesbsd系统相关，具体作用不明）| |-- private （？一些私有的头文件）| |-- stdio （stdio实现）| |-- stdlib （stdlib实现）| |-- string （string函数实现）| |-- tools （几个工具）| |-- tzcode （时区相关代码）| |-- unistd （unistd实现）| `-- zoneinfo （时区信息）|-- libdl （libdl实现，dl是动态链接，提供访问动态链接库的功能）|-- libm （libm数学库的实现，）| |-- alpha （apaha架构）| |-- amd64 （amd64架构）| |-- arm （arm架构）| |-- bsdsrc （？bsd的源码）| |-- i386 （i386架构）| |-- i387 （i387架构？）| |-- ia64 （ia64架构）| |-- include （头文件）| |-- man （数学函数，后缀名为.3，一些为freeBSD的库文件）| |-- powerpc （powerpc架构）| |-- sparc64 （sparc64架构）| `-- src （源代码）|-- libstdc++ （libstdc++ C++实现库）| |-- include （头文件）| `-- src （源码）|-- libthread_db （多线程程序的调试器库）| `-- include （头文件）`-- linker （动态链接器）`-- arch （支持arm和x86两种架构） 1234567891011121314151617181920212223bootable 目录.|-- bootloader （适合各种bootloader的通用代码）| `-- legacy （估计不能直接使用，可以参考）| |-- arch_armv6 （V6架构，几个简单的汇编文件）| |-- arch_msm7k （高通7k处理器架构的几个基本驱动）| |-- include （通用头文件和高通7k架构头文件）| |-- libboot （启动库，都写得很简单）| |-- libc （一些常用的c函数）| |-- nandwrite （nandwirte函数实现）| `-- usbloader （usbloader实现）|-- diskinstaller （android镜像打包器，x86可生产iso）`-- recovery （系统恢复相关） |-- edify （升级脚本使用的edify脚本语言） |-- etc （init.rc恢复脚本） |-- minui （一个简单的UI） |-- minzip （一个简单的压缩工具） |-- mtdutils （mtd工具） |-- res （资源） | `-- images （一些图片） |-- tools （工具） | `-- ota （OTA Over The Air Updates升级工具）`-- updater （升级器） 1234567891011121314151617181920212223242526272829303132333435build目录.|-- core （核心编译规则）|-- history （历史记录）|-- libs| `-- host （主机端库，有android “cp”功能替换）|-- target （目标机编译对象）| |-- board （开发平台）| | |-- emulator （模拟器）| | |-- generic （通用）| | |-- idea6410 （自己添加的）| | `-- sim （最简单）| `-- product （开发平台对应的编译规则）| `-- security （密钥相关）`-- tools （编译中主机使用的工具及脚本） |-- acp （Android &quot;acp&quot; Command） |-- apicheck （api检查工具） |-- applypatch （补丁工具） |-- apriori （预链接工具） |-- atree （tree工具） |-- bin2asm （bin转换为asm工具） |-- check_prereq （检查编译时间戳工具） |-- dexpreopt （模拟器相关工具，具体功能不明） |-- droiddoc （？作用不明，java语言，网上有人说和JDK5有关） |-- fs_config （This program takes a list of files and directories） |-- fs_get_stats （获取文件系统状态） |-- iself （判断是否ELF格式） |-- isprelinked （判断是否prelinked） |-- kcm （按键相关） |-- lsd （List symbol dependencies） |-- releasetools （生成镜像的工具及脚本） |-- rgb2565 （rgb转换为565） |-- signapk （apk签名工具） |-- soslim （strip工具）`-- zipalign （zip archive alignment tool） 1234567891011121314151617dalvik目录 dalvik虚拟机.|-- dalvikvm （main.c的目录）|-- dexdump （dex反汇编）|-- dexlist （List all methods in all concrete classes in a DEX file.）|-- dexopt （预验证与优化）|-- docs （文档）|-- dvz （和zygote相关的一个命令）|-- dx （dx工具，将多个java转换为dex）|-- hit （？java语言写成）|-- libcore （核心库）|-- libcore-disabled （？禁用的库）|-- libdex （dex的库）|-- libnativehelper （Support functions for Android&apos;s class libraries）|-- tests （测试代码）|-- tools （工具）`-- vm （虚拟机实现） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455```development 目录 （开发者需要的一些例程及工具）|-- apps （一些核心应用程序）| |-- BluetoothDebug （蓝牙调试程序）| |-- CustomLocale （自定义区域设置）| |-- Development （开发）| |-- Fallback （和语言相关的一个程序）| |-- FontLab （字库）| |-- GestureBuilder （手势动作）| |-- NinePatchLab （？）| |-- OBJViewer （OBJ查看器）| |-- SdkSetup （SDK安装器）| |-- SpareParts （高级设置）| |-- Term （远程登录）| `-- launchperf （？）|-- build （编译脚本模板）|-- cmds （有个monkey工具）|-- data （配置数据）|-- docs （文档）|-- host （主机端USB驱动等）|-- ide （集成开发环境）|-- ndk （本地开发套件——c语言开发套件）|-- pdk （Plug Development Kit）|-- samples （例程）| |-- AliasActivity （？）| |-- ApiDemos （API演示程序）| |-- BluetoothChat （蓝牙聊天）| |-- BrowserPlugin （浏览器插件）| |-- BusinessCard （商业卡）| |-- Compass （指南针）| |-- ContactManager （联系人管理器）| |-- CubeLiveWallpaper （动态壁纸的一个简单例程）| |-- FixedGridLayout （像是布局）| |-- GlobalTime （全球时间）| |-- HelloActivity （Hello）| |-- Home （Home）| |-- JetBoy （jetBoy游戏）| |-- LunarLander （貌似又是一个游戏）| |-- MailSync （邮件同步）| |-- MultiResolution （多分辨率）| |-- MySampleRss （RSS）| |-- NotePad （记事本）| |-- RSSReader （RSS阅读器）| |-- SearchableDictionary （目录搜索）| |-- SimpleJNI （JNI例程）| |-- SkeletonApp （空壳APP）| |-- Snake （snake程序）| |-- SoftKeyboard （软键盘）| |-- Wiktionary （？维基）| `-- WiktionarySimple（？维基例程）|-- scripts （脚本）|-- sdk （sdk配置）|-- simulator （？模拟器）|-- testrunner （？测试用）`-- tools （一些工具） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374external 目录.|-- aes （AES加密）|-- apache-http （网页服务器）|-- astl （ASTL (Android STL) is a slimmed-down version of the regular C++ STL.）|-- bison （自动生成语法分析器，将无关文法转换成C、C++）|-- blktrace （blktrace is a block layer IO tracing mechanism）|-- bluetooth （蓝牙相关、协议栈）|-- bsdiff （diff工具）|-- bzip2 （压缩工具）|-- clearsilver （html模板系统）|-- dbus （低延时、低开销、高可用性的IPC机制）|-- dhcpcd （DHCP服务）|-- dosfstools （DOS文件系统工具）|-- dropbear （SSH2的server）|-- e2fsprogs （EXT2文件系统工具）|-- elfcopy （复制ELF的工具）|-- elfutils （ELF工具）|-- embunit （Embedded Unit Project）|-- emma （java代码覆盖率统计工具）|-- esd （Enlightened Sound Daemon，将多种音频流混合在一个设备上播放）|-- expat （Expat is a stream-oriented XML parser.）|-- fdlibm （FDLIBM (Freely Distributable LIBM)）|-- freetype （字体）|-- fsck_msdos （dos文件系统检查工具）|-- gdata （google的无线数据相关）|-- genext2fs （genext2fs generates an ext2 filesystem as a normal (non-root) user）|-- giflib （gif库）|-- googleclient （google用户库）|-- grub （This is GNU GRUB, the GRand Unified Bootloader.）|-- gtest （Google C++ Testing Framework）|-- icu4c （ICU(International Component for Unicode)在C/C++下的版本）|-- ipsec-tools （This package provides a way to use the native IPsec functionality ）|-- iptables （防火墙）|-- jdiff （generate a report describing the difference between two public Java APIs.）|-- jhead （jpeg头部信息工具）|-- jpeg （jpeg库）|-- junit （JUnit是一个Java语言的单元测试框架）|-- kernel-headers （内核的一些头文件）|-- libffi （libffi is a foreign function interface library.）|-- libpcap （网络数据包捕获函数）|-- libpng （png库）|-- libxml2 （xml解析库）|-- mtpd （一个命令）|-- netcat （simple Unix utility which reads and writes dataacross network connections）|-- netperf （网络性能测量工具）|-- neven （看代码和JNI相关）|-- opencore （多媒体框架）|-- openssl （SSL加密相关）|-- openvpn （VPN开源库）|-- oprofile （OProfile是Linux内核支持的一种性能分析机制。）|-- ping （ping命令）|-- ppp （pppd拨号命令，好像还没有chat）|-- proguard （Java class file shrinker, optimizer, obfuscator, and preverifier）|-- protobuf （a flexible, efficient, automated mechanism for serializing structured data）|-- qemu （arm模拟器）|-- safe-iop （functions for performing safe integer operations ）|-- skia （skia图形引擎）|-- sonivox （sole MIDI solution for Google Android Mobile Phone Platform）|-- speex （Speex编/解码API的使用(libspeex)）|-- sqlite （数据库）|-- srec （Nuance 公司提供的开源连续非特定人语音识别）|-- strace （trace工具）|-- svox （Embedded Text-to-Speech）|-- tagsoup （TagSoup是一个Java开发符合SAX的HTML解析器）|-- tcpdump （抓TCP包的软件）|-- tesseract （Tesseract Open Source OCR Engine.）|-- tinyxml （TinyXml is a simple, small, C++ XML parser）|-- tremor （I stream and file decoder provides an embeddable,integer-only library）|-- webkit （浏览器核心）|-- wpa_supplicant （无线网卡管理）|-- xmlwriter （XML 编辑工具）|-- yaffs2 （yaffs文件系统）`-- zlib （a general purpose data compression library） 123456789101112131415161718192021222324252627282930313233343536frameworks 目录 （核心框架——java及C++语言）.|-- base （基本内容）| |-- api （？都是xml文件，定义了java的api？）| |-- awt （AWT库）| |-- build （空的）| |-- camera （摄像头服务程序库）| |-- cmds （重要命令：am、app_proce等）| |-- core （核心库）| |-- data （字体和声音等数据文件）| |-- docs （文档）| |-- graphics （图形相关）| |-- include （头文件）| |-- keystore （和数据签名证书相关）| |-- libs （库）| |-- location （地区库）| |-- media （媒体相关库）| |-- obex （蓝牙传输库）| |-- opengl （2D-3D加速库）| |-- packages （设置、TTS、VPN程序）| |-- sax （XML解析器）| |-- services （各种服务程序）| |-- telephony （电话通讯管理）| |-- test-runner （测试工具相关）| |-- tests （各种测试）| |-- tools （一些叫不上名的工具）| |-- vpn （VPN）| `-- wifi （无线网络）|-- opt （可选部分）| |-- com.google.android （有个framework.jar）| |-- com.google.android.googlelogin （有个client.jar）| `-- emoji （standard message elements）`-- policies （Product policies are operating system directions aimed at specific uses） `-- base |-- mid （MID设备） `-- phone （手机类设备，一般用这个） 1234567891011121314151617181920212223242526272829303132333435363738394041424344hardware 目录 （部分厂家开源的硬解适配层HAL代码）|-- broadcom （博通公司）| `-- wlan （无线网卡）|-- libhardware （硬件库）| |-- include （头文件）| `-- modules （Default (and possibly architecture dependents) HAL modules）| |-- gralloc （gralloc显示相关）| `-- overlay （Skeleton for the &quot;overlay&quot; HAL module.）|-- libhardware_legacy （旧的硬件库）| |-- flashlight （背光）| |-- gps （GPS）| |-- include （头文件）| |-- mount （旧的挂载器）| |-- power （电源）| |-- qemu （模拟器）| |-- qemu_tracing （模拟器跟踪）| |-- tests （测试）| |-- uevent （uevent）| |-- vibrator （震动）| `-- wifi （无线）|-- msm7k （高通7k处理器开源抽象层）| |-- boot （启动）| |-- libaudio （声音库）| |-- libaudio-qsd8k （qsd8k的声音相关库）| |-- libcamera （摄像头库）| |-- libcopybit （copybit库）| |-- libgralloc （gralloc库）| |-- libgralloc-qsd8k （qsd8k的gralloc库）| |-- liblights （背光库）| `-- librpc （RPC库）|-- ril （无线电抽象层）| |-- include （头文件）| |-- libril （库）| |-- reference-cdma-sms （cdma短信参考）| |-- reference-ril （ril参考）| `-- rild （ril后台服务程序）`-- ti （ti公司开源HAL） |-- omap3 （omap3处理器） | |-- dspbridge （DSP桥） | |-- libopencorehw （opencore硬件库） | |-- liboverlay （overlay硬件库） | |-- libstagefrighthw （stagefright硬件库） | `-- omx （omx组件） `-- wlan （无线网卡） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758packages 目录.|-- apps （应用程序库）| |-- AlarmClock （闹钟）| |-- Bluetooth （蓝牙）| |-- Browser （浏览器）| |-- Calculator （计算器）| |-- Calendar （日历）| |-- Camera （相机）| |-- CertInstaller （在Android中安装数字签名，被调用）| |-- Contacts （拨号(调用)、联系人、通话记录）| |-- DeskClock （桌面时钟）| |-- Email （Email）| |-- Gallery （相册，和Camera类似，多了列表）| |-- Gallery3D （？3D相册）| |-- GlobalSearch （为google搜索服务，提供底层应用）| |-- GoogleSearch （google搜索）| |-- HTMLViewer （浏览器附属界面，被浏览器应用调用，同时提供存储记录功能）| |-- IM （即时通讯，为手机提供信号发送、接收、通信的服务）| |-- Launcher （登陆启动项，显示图片框架等等图形界面）| |-- Launcher2 （登陆启动项，负责应用的调用）| |-- Mms （？彩信业务）| |-- Music （音乐播放器）| |-- PackageInstaller （安装、卸载程序的响应）| |-- Phone （电话拨号程序）| |-- Provision （预设应用的状态，使能应用）| |-- Settings （开机设定，包括电量、蓝牙、设备信息、界面、wifi等）| |-- SoundRecorder （录音机，可计算存储所需空间和时间）| |-- Stk （接收和发送短信）| |-- Sync （空） -------○1| |-- Updater （空）| `-- VoiceDialer （语音识别通话）|-- inputmethods （输入法）| |-- LatinIME （拉丁文输入法）| |-- OpenWnn （OpenWnn输入法）| `-- PinyinIME （拼音输入法）|-- providers （提供器，提供应用程序、界面所需的数据）| |-- ApplicationsProvider （应用程序提供器，提供应用程序启动项、更新等）| |-- CalendarProvider （日历提供器）| |-- ContactsProvider （联系人提供器）| |-- DownloadProvider （下载管理提供器）| |-- DrmProvider （创建和更新数据库时调用）| |-- GoogleContactsProvider （联系人提供器的子类，用以同步联系人）| |-- GoogleSubscribedFeedsProvider（设置信息提供器）| |-- ImProvider （空）| |-- ManagementProvider （空）| |-- MediaProvider （媒体提供器，提供存储数据）| |-- TelephonyProvider （彩信提供器）| |-- UserDictionaryProvider （用户字典提供器，提供用户常用字字典）| `-- WebSearchProvider （空）|-- services| |-- EasService （空）| `-- LockAndWipe （空）`-- wallpapers （墙纸） |-- Basic （基本墙纸，系统内置墙纸） |-- LivePicker （选择动态壁纸） |-- MagicSmoke （壁纸特殊效果） `-- MusicVisualization （音乐可视化，图形随音乐而变化） 1234567891011121314151617181920212223prebuilt 目录 （x86和arm架构下预编译的一些资源）.|-- android-arm （arm-android相关）| |-- gdbserver （gdb调试器）| `-- kernel （模拟的arm内核）|-- android-x86 （x86-android相关）| `-- kernel （空的）|-- common （通用编译好的代码，应该是java的）|-- darwin-x86 （drawin x86平台）| `-- toolchain （工具链）| |-- arm-eabi-4.2.1 | |-- arm-eabi-4.3.1 | `-- arm-eabi-4.4.0 |-- darwin-x86_64 （drawin x86 64bit平台）|-- linux-x86 （linux x86平台）| `-- toolchain （工具链，我们应该主要用这个）| |-- arm-eabi-4.2.1 | |-- arm-eabi-4.3.1 | |-- arm-eabi-4.4.0 | `-- i686-unknown-linux-gnu-4.2.1 （x86版编译器）|-- linux-x86_64 （linux x86 64bit平台）|-- windows （windows平台）`-- windows-x86_64 （64bit windows平台） 123456789101112131415161718192021222324252627282930313233343536373839404142system 目录 （底层文件系统库、应用及组件——C语言）.|-- Bluetooth （蓝牙相关）|-- core （系统核心工具盒接口）| |-- adb （adb调试工具）| |-- cpio （cpio工具，创建img）| |-- debuggerd （调试工具）| |-- fastboot （快速启动相关）| |-- include （系统接口头文件）| |-- init （init程序源代码）| |-- libacc （轻量级C编译器）| |-- libctest （libc测试相关）| |-- libcutils （libc工具）| |-- liblog （log库）| |-- libmincrypt （加密库）| |-- libnetutils （网络工具库）| |-- libpixelflinger （图形处理库）| |-- libsysutils （系统工具库）| |-- libzipfile （zip库）| |-- logcat （查看log工具）| |-- logwrapper （log封装工具）| |-- mkbootimg （制作启动boot.img的工具盒脚本）| |-- netcfg （网络配置netcfg源码）| |-- nexus （google最新手机的代码）| |-- rootdir （rootfs，包含一些etc下的脚本和配置）| |-- sh （shell代码）| |-- toolbox （toolbox，类似busybox的工具集）| `-- vold （SD卡管理器）|-- extras （额外工具）| |-- latencytop （a tool for software developers ，identifying system latency happen）| |-- libpagemap （pagemap库）| |-- librank （Java Library Ranking System库）| |-- procmem （pagemap相关）| |-- procrank （Java Library Ranking System相关）| |-- showmap （showmap工具）| |-- showslab （showslab工具）| |-- sound （声音相关）| |-- su （su命令源码）| |-- tests （一些测试工具）| `-- timeinfo （时区相关）`-- wlan （无线相关） `-- ti （ti网卡相关工具及库） 12345678910111213141516171819202122vendor 目录 （厂家定制内容）|-- aosp （android open source project）| `-- products （一些板级规则）|-- htc （HTC公司）| |-- common-open （通用部分）| | `-- akmd （解压img用的工具）| |-- dream-open （G1开放部分）| |-- prebuilt-open （预编译开放部分）| `-- sapphire-open （sapphire这款型号开放内容）|-- pv-open （没东西）|-- qcom （里面基本是空的）`-- sample （google提供的样例） |-- apps （应用） | |-- client （用户） | `-- upgrade （升级） |-- frameworks （框架） | `-- PlatformLibrary （平台库） |-- products （产品） |-- sdk_addon （sdk添加部分） `-- skins （皮肤） `-- WVGAMedDpi （WVGA适用的图片） 123456789101112131415161718192021222324252627282930313233编译结果：out├── host SDK 中的各种工具(emulator，adb...)│ ├── common 所有主机都用的通用库(java库)│ │ └── obj│ │ └── JAVA_LIBRARIES│ └── Linux-x86 用linux-x86主机上工具程序└── target 目标机上运行的各种程序 ├── common 所有产品都用的通用程序(java程序或库) │ ├── docs 文档目录 │ ├── obj 中间文件 │ │ ├── APPS 应用程序的中间文件 │ │ └── JAVA_LIBRARIES java库的中间文件 │ └── R 资源文件(java代码形式) │ ├── android │ ├── com │ ├── jp │ └── org └── product 产品(特定平台)专用程序 └── fspad-723 fspad-723型号产品(全志A23平台)程序 ├── data 用户数据, 该目录中的内容被挂载到/data目录下 ├── obj ├── recovery 恢复版的根文件系统 ├── root 根文件系统，装有最基本的命令, 该目录中的内容被挂载到/目录下 ├── symbols ├── system 系统文件系统, 该目录中的内容被挂载到/system目录下 ------------------------------------------------------------- ├── ramdisk.img root目录打包 ├── ramdisk-recovery.img recovery目录打包 ├── boot.img kernel + ramdisk.img ├── system.img system目录打包 ├── userdata.img data目录打包 └── recovery.img kernel + ramdisk-recovery.img 参考资料： CSDN Android系统编译原理 进则净土，退则凡尘 的博客","tags":[{"name":"SDK","slug":"SDK","permalink":"http://yoursite.com/tags/SDK/"}]},{"title":"ubuntu 压缩解压命令","date":"2017-09-13T01:56:56.021Z","path":"2017/09/13/Ubuntu 压缩解压/","text":"ZIPzip文件解压：unzip xxx.zipzip文件压缩：zip -r xxx.zip xxx/ TARtar文件解压：tar xvf xxx.tartar文件压缩：tar cvf xxx.tar xxx/ tar.gztar.gz文件解压：tar zcvf xxx.tar.gz xxx/tar.gz文件压缩：tar zxvf xxx.tar.gz .gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName .Z解压：uncompress FileName.Z压缩：compress FileName .tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName .tgz解压：tar zxvf FileName.tgz压缩：未知 .tar.tgz解压：tar zxvf FileName.tar.tgz压缩：tar zcvf FileName.tar.tgz FileName .rar解压：rar a FileName.rar压缩：r ar e FileName.rar分卷压缩 tar分卷压缩: tar cvzpf - eclipse | split -d -b 50m上面的命令是将eclipse这个文件夹分卷压缩，每卷50m，注意eclipse 前面有空格.压缩完之后，会被命名为x00,x01,x02。。。 分卷tar压缩文件解压首先需要合并：合并的命令是：cat x*&gt;eclipse.tar.gz然后解压：tar xzvf eclipse.tar.gz","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"Android 开发环境配置","date":"2017-09-13T01:56:56.021Z","path":"2017/09/13/Andrid-开发环境配置/","text":"##开发环境配置 android开发，首先建议使用ubuntu或者使用Moc，当然对我这样的穷屌丝。moc是买不起的我只能使用ubuntu了。至于为什么要这样做那，理解android机制或者有过ROM开发经验的都会知道，对于处入门的小白可以不必纠结直接上ubuntu就行了。 ###1、Ubuntu 安装ubunu安装其实很简单网上有很多教程我这里就不一一展开说了,可以参考以下链接安装baidu 安装好ubutun，接下来就是安装android开发的必要环境及工具：(如果你可以翻墙可以参考谷歌官方推荐安装) openjdk安装并配置环境变量 android 源码编译必要工具sudo apt-get install git gnupg flex bison gperf build-essential zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dri:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 dpkg-devsudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib/i386-linux-gnu/libGL.so 设置usb权限（将如下内容加入到/etc/udev/rules.d/51-android.rules文件中） 12345678910111213141516171819202122232425262728293031323334# adb protocol on passion (Nexus One) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;18d1&quot;, ATTR&#123;idProduct&#125;==&quot;4e12&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # fastboot protocol on passion (Nexus One) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;0bb4&quot;, ATTR&#123;idProduct&#125;==&quot;0fff&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # adb protocol on crespo/crespo4g (Nexus S) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;18d1&quot;, ATTR&#123;idProduct&#125;==&quot;4e22&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # fastboot protocol on crespo/crespo4g (Nexus S) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;18d1&quot;, ATTR&#123;idProduct&#125;==&quot;4e20&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # adb protocol on stingray/wingray (Xoom) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;22b8&quot;, ATTR&#123;idProduct&#125;==&quot;70a9&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # fastboot protocol on stingray/wingray (Xoom) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;18d1&quot;, ATTR&#123;idProduct&#125;==&quot;708c&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # adb protocol on maguro/toro (Galaxy Nexus) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;04e8&quot;, ATTR&#123;idProduct&#125;==&quot;6860&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # fastboot protocol on maguro/toro (Galaxy Nexus) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;18d1&quot;, ATTR&#123;idProduct&#125;==&quot;4e30&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # adb protocol on panda (PandaBoard) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;0451&quot;, ATTR&#123;idProduct&#125;==&quot;d101&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # adb protocol on panda (PandaBoard ES) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;18d1&quot;, ATTR&#123;idProduct&#125;==&quot;d002&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # fastboot protocol on panda (PandaBoard) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;0451&quot;, ATTR&#123;idProduct&#125;==&quot;d022&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # usbboot protocol on panda (PandaBoard) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;0451&quot;, ATTR&#123;idProduct&#125;==&quot;d00f&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # usbboot protocol on panda (PandaBoard ES) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;0451&quot;, ATTR&#123;idProduct&#125;==&quot;d010&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # adb protocol on grouper/tilapia (Nexus 7) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;18d1&quot;, ATTR&#123;idProduct&#125;==&quot;4e42&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # fastboot protocol on grouper/tilapia (Nexus 7) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;18d1&quot;, ATTR&#123;idProduct&#125;==&quot;4e40&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # adb protocol on manta (Nexus 10) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;18d1&quot;, ATTR&#123;idProduct&#125;==&quot;4ee2&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; # fastboot protocol on manta (Nexus 10) SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;18d1&quot;, ATTR&#123;idProduct&#125;==&quot;4ee0&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot; git 及 repo安装没有什么难度，问一下度娘相信你一定能找到你满意的答案 以上操作成功可以下载一套安装源码试一下：国内镜像下载Android源码使用国内的镜像服务器下载，可以减少时间。安卓源码sync结束请直行以下指令123source build/envsetup.shlunch aosp_flo-userdebugmake -j8 编译结束生成的文件都在out目录下。 除此之外我还习惯使用如下工具meld（对比工具），sublime（文本编辑工具），TeamView（远程控制工具）2、安装eclipse及AS","tags":[]},{"title":"自我介绍","date":"2017-02-13T12:46:25.000Z","path":"2017/02/13/自我介绍/","text":"XinMing-Liu.github.io 先来一段百度到的一篇短文，感觉写的很好，很适合我这里就索性引用一下。 123456789 在沧海中,我是一粒沙. 我,隐藏在茫茫人海中.我既没有柔美的身段,也没有亮丽的双眸,但我有进取的心,有似水的梦怀,有崇高的理想,我坚信腹有诗书气自华. 我,不愿随波逐流.在《未选择的路》中弗罗斯特曾写过：“黄色的树林里分出两条路,可惜我不能同时去涉足.”“而我选择了人迹更少的一条,从此决定了我一生的道路.”只融于大众的我便成为了实实在在的平凡人.我不愿去走别人庸俗的老路,去过跟别人同样庸俗的生活.在偷觑他人的同时,也否定了自己. 我,不愿随波逐流.在《未选择的路》中弗罗斯特曾写过：“黄色的树林里分出两条路,可惜我不能同时去涉足.”“而我选择了人迹更少的一条,从此决定了我一生的道路.”只融于大众的我便成为了实实在在的平凡人.我不愿去走别人庸俗的老路,去过跟别人同样庸俗的生活.在偷觑他人的同时,也否定了自己. 我,幽默宽容.我向来不喜欢看别人满面怒容的样子,我认为他人的笑才是天下最美的风景.所以每天,我都会变成一颗开心果,尽可能地给他们带去欢乐.“比大地宽阔的是海洋,比海洋宽阔的是天空,比天空宽阔的是人的心灵.”宽容使狭隘的胸怀容纳百川,所以对待别人的过失,我都付笑谈中. 我,要做自己.齐白石老先生曾说过；“学我者生,似我者死.”走不出前人的框架,自然也就不会有自己的天地.当流行泡沫小说时,我感觉那时在浪费时间,当流行网络游戏时,我感觉那是在虚度青春.要做自己,看清真实的我,拿出十二分的信心,告诉自己：“我就是我,凭什么跟他一样?!”抛掉那些人为的浮华雕饰,亮出自己的王牌,追求自己的个性,做我自己,最好! 我,积极进取.小小的我是一粒沙,但不甘于落后,一生庸碌无为.我愿做生命的酋长,做一粒不朽的珍珠泪.路漫漫其修远兮,吾将上下而求索.我渴望朝向艺术之塔,文化之巅,事业之厦,庆功之缘,不负这繁花似锦的时代,留一行扎实稳健的足迹,把美和爱洒向人间…… 这就是我,风华正茂的我,意气风发的我. 这就是我,幽默宽容的我,不甘落后的我. 下边就介绍一下我的工作经历。 在这里写的文章，都是我所了解的领域，或者从事过的。这可能会对看我写的文章有一定的指引作用。我是14年毕业的大学生，虽然工作了两年多了，依然保持着我是刚毕业的大学生的心态：时刻学习。我是10级电子信息专业毕业，学电子自我感觉枯燥无味，感觉计算机专业不错。所以大学我就自学了计算专业的很多东西：PS，3D MAX，CAD,C#,JAVA,C,汇编，HTML，网络工程等等。后来毕业，刚开始志气满满，我想放弃原本电子专业的工作方向，找个计算机或者设计美术方向的工作。找了一段时间发现并不顺利。毕竟自学的东西不够系统，面试的HR多少也会有些看法。有一家叫 中海达 的公司决定要我，去做3d原型设计.因为学校还有毕业答辩等一系列的问题。后来决定重新考虑我的方向，无意间联系了一家做通讯的公司。（有过面试经历的都会知道，当你面试很多家之后你要求的条件会越来低）抱着先工作之后再考虑的心态办理了入职。也是我工作的第一家公司。通信行业也算是与我本专业相通的行业。算是又回到电子专业上，由于大学课程学习的还可以，很快就上手了，截止目前交出的徒弟也不少了。后来感觉通讯也就那么回事，指令就是那么一些像get . defaultroute ；st cell；st rru；license server等。每天处理的问题无非就那么几种，驻波比；掉电；高误码；时钟校准失败等等处理步骤也是那几条指令。刚开始是做基站督导，后来在移动联通后台。发现同样的无聊，后来开始我人生的第二次选择。android程序员，基于之前大学的积累，开始自学，自学了大约三四个月，提出离职来到北京找到第一份android开发的工作。写安卓应用的后来发现我有很多需要继续掌握的东西，就开了我的知识积累的开始。写了一段时间的apk，由于个人原因离职了，来到这一家开发系统的公司。在这里让我学到了很多，即便是每天加班到九点依然过的很开心，因为我每天或多或少都有所收获。身边同事都很厉害，阿里，360等核心主干组成的团队体验就是不一样，公司的制度让我体验了一次，之前从不奢求的工作环境，工作氛围。刚开始先从底层做起，这其实也符合我只菜鸟。由于我们开发的是android系统，开始我开发了一段时间预置应用，像计算器，录音机，问题反馈，文本编辑器等等后来就开始适配工作，虽然每个人都说适配是一个辛苦活，但是我发现有学到了很多之前从没接触到的东西，让我对系统架构有了深入的了解。由于我们的工作环境是ubuntu，之前我是没怎么接触，所以就从学习基本的linux指令开始。之后学习git指令，repo指令这些必备技能差不多了，就开始了适配工作，首先了解了我们系统的主要修改，及每个目录对应的功能。然后有机会调试系统源码，调试系统中的frameworks中的一些东西。了解了android的编译原理，修复编译的各种问题。当编译了解的差不多了对于整个系统操作就发现更加得心应手了。后来系统上出现的各种问题处理起来就没感觉那么吃力了，当然这里边处理问题的思路很重要，不要看到问题心慌。有问题定位问题的能力是在处理问题中慢慢积累的。这里这要说明几点，遇到问题问几个为什么？原生系统有没有这个问题？原生问题就找厂商处理。加上我们的代码之后的问题，就看这个问题是不是在nexus上也出现？nexus上有的问题是开发人员要处理的。剩下的就是我处理的问题。现在，就要去追源码，wifi模块就要去看wifi相关的代码。窗口模块就要看窗口的代码。不同厂家的代码规范不一样，像MTK的代码，他们一般不修改谷歌的原始代码而是添加overlay的形式去实现他们想要的效果。这种情况是防不胜防的。只能慢慢研究了。还有要想有更高的工作效率就多学学git指令，通过git管理你的仓库会发现便捷很多。","tags":[]}]